1. 第三方库依赖冲突统一管理
   配置dependencies.gradle，里面统一配置依赖版本及公用变量定义

2. 资源冲突
   在每一个子模块的build.gradle加上对应资源文件标识符resourcePrefix "xxx_"前缀
   建议xxx以模块名命名即可

3. App模块通过buildWithOtherModule动态build其他模块，module模块通过buildModule打开是否作为module使用
4. 开源库的代码隔离设计



基础结构

                app

accountcomponent   featurecomponent

        componentservice

            componentlib

        basicres    basiclib



架构
使用全新的谷歌架构实现
lifecycle room
https://medium.com/google-developers/viewmodels-and-livedata-patterns-antipatterns-21efaef74a54
1. 使用数据仓库：远端数据，本地数据，内存缓存。建议使用分离独立的单例仓库类来处理数据业务

http://bytes.schibsted.com/data-binding-android-architecture-components-preview/
1. 区分LiveData和ObserableData

依赖注入框架
1. dragger2
http://www.jianshu.com/p/cd2c1c9f68d4
Inject主要是用来标注目标类的依赖和依赖的构造函数
Component它是一个桥梁，一端是目标类，另一端是目标类所依赖类的实例，它也是注入器（Injector）负责把目标类所依赖类的实例注入到目标类中，同时它也管理Module。
Module和Provides是为解决第三方类库而生的，Module是一个简单工厂模式
Module可以包含创建类实例的方法，这些方法用Provides来标注
2. 查找顺序：优先查找module暴露的依赖，其次再查找Inject注解的依赖
3. 如果实例化对象存在多个方法呢，需要用Qualifier注解解决依赖注入迷失





设计风格
快速开发MD设计    https://zhuanlan.zhihu.com/p/20870983
MD快速导入插件    https://github.com/konifar/android-material-design-icon-generator-plugin
无设计开发漂亮app  https://www.race604.com/develpor-beautiful-app-without-ps/
卡片风格设计 http://blog.csdn.net/ygilove/article/details/57077745
https://www.materialpalette.com/icons
http://www.iconfont.cn/
https://material.io/icons/
htps://medium.com/uxabc/designing-for-different-platforms-dc0d40eb18c3t
http://next.36kr.com/posts/collections/200


